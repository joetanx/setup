## 1. Install Docker on Red Hat or Rocky Linux

```sh
yum config-manager --add-repo https://download.docker.com/linux/rhel/docker-ce.repo
yum -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
systemctl enable --now docker
```

### 1.1. Basic Docker commands

Pull container image

```sh
docker pull docker.io/library/nginx
```

Docker run example:

```sh
docker run -d --name nginx \
--restart unless-stopped -p 80:80 \
-v /etc/nginx/nginx.conf:/etc/nginx/nginx.conf:ro \
docker.io/library/nginx:latest
```

|Option|Purpose|
|---|---|
|`-d`, `--detach`|Run container in background and print container ID|
|`-it`: `--interactive` + `--tty`|Keep STDIN open even if not attached + Allocate a pseudo-TTY|
|`--name <string>`|Assign a name to the container|
|`--restart <string>`|Restart policy to apply when a container exits (default "no")|
|`--rm`|Automatically remove the container and its associated anonymous volumes when it exits<br>• use with `-d`: container runs like a process and discard itself after<br>• use with `-it`: usually for containers that are client utilities, interact and discard after|
|`-p`, `--publish <host_port>:<container_port>`|Publish a container's port(s) to the host|
|`-v`, `--volume <host_dir>:<container_dir>:<options>`|Bind mount a volume<br>SELinux options<br>• `:z`: sets shared SELinux label (share volume to multiple containers)<br>• `:Z`: sets private SELinux label (volume used by only one container)<br>• `:ro`: mounts volume as read-only inside container|
|`--network <network>`|Connect a container to a network|
|`--network-alias <list>`|Add network-scoped alias for the container|

Firewall commands to allow access to the container service mapped to the host port

```sh
firewall-cmd --permanent --add-service http && firewall-cmd --reload
```

## 2. Container name resolution

### 2.1. Containers on default `bridge` network cannot communicate using container names

Run a nginx and a client container:

```sh
docker run -d --name nginx docker.io/library/nginx
docker run -it --name client docker.io/library/alpine
```

Check that both containers are on the `bridge` network:

```console
[root@docker ~]# docker inspect bridge
[
    {
        "Name": "bridge",
        ⋮
        "Containers": {
            "b5ebb93f427924f3cffc65d5b18cc4036536c82a348bd6204ff8414026c95d5c": {
                "Name": "nginx",
                "EndpointID": "3a5e54917281253c40cdf1fcdf59bcf4897e1bcbcaadbd5b6202c8a83f0ab564",
                "MacAddress": "22:b8:a6:d8:ef:63",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            },
            "bdaa15d84ee2c1fdcc6d2816cd2197d9fe8662c5e360799974a5a57b4023bcdc": {
                "Name": "client",
                "EndpointID": "801817de93dc747c421e4d88d5105847b736eb8ddc972ae8b9d92912accdb134",
                "MacAddress": "f2:26:24:9d:7c:99",
                "IPv4Address": "172.17.0.3/16",
                "IPv6Address": ""
            }
        },
        ⋮
```

Attempt to ping nginx from client fails:

```sh
/ # ping nginx
ping: bad address 'nginx'
```

This is because the Docker host's DNS server is populated in containers' `/etc/resolv.conf` in default `bridge` network:

```sh
/ # cat /etc/resolv.conf
# Generated by Docker Engine.
# This file can be edited; Docker Engine will not make further changes once it
# has been modified.

nameserver 192.168.17.1
search vx

# Based on host file: '/etc/resolv.conf' (legacy)
# Overrides: []
```

> [!Tip]
>
> ### Useful container diagnostic commands
>
> 1. get a console to the nginx container:
>
> ```sh
> docker exec -it nginx /bin/bash
> ```
>
> 2. get IP address of the nginx container:
>
> ```sh
> docker exec nginx hostname -i
> ```
>
> 3. `wget` to print web request to stdout:
>
> ```sh
> wget -O - http://nginx
> ```
>
> 4. remove containers (`-f` removes non running containers too):
>
> ```sh
> docker rm -f nginx client
> ```

### 2.2. Containers on custom network can communicate using container names

Create a docker network:

```sh
docker network create app
```

Run a nginx and a client container on the custom network:

```sh
docker run -d --name nginx --network app docker.io/library/nginx
docker run -it --name client --network app docker.io/library/alpine
```

Check that both containers are on the custom network:

```console
[root@docker ~]# docker inspect bridge
[
    {
        "Name": "app",
        ⋮
        "Containers": {
            "28a445e8df5ebb93615b331408751e50142f210febb3b8a7cefbfd8c3a4c8d01": {
                "Name": "client",
                "EndpointID": "2adbb6db0bd267cf94e3c4b38b61035e0ed440675452a4b70f431c08e611b89f",
                "MacAddress": "66:6a:e7:99:71:bd",
                "IPv4Address": "172.18.0.3/16",
                "IPv6Address": ""
            },
            "a621744f37a68d0d3d54dadc126fbfbaf2fb7b011afcfb7f2599f71f82717c9c": {
                "Name": "nginx",
                "EndpointID": "837c57849fdc64c0046dcd48f9f5ec844f227bf6c534bca84e5ca6244a3ae273",
                "MacAddress": "fa:5e:a2:45:38:8f",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        ⋮
```

Attempt to connect nginx from client works:

```sh
/ # ping nginx -c 1
PING nginx (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.039 ms

--- nginx ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.039/0.039/0.039 ms
/ # wget -O /dev/null nginx
Connecting to nginx (172.18.0.2:80)
saving to '/dev/null'
null                 100% |********************************|   615  0:00:00 ETA
'/dev/null' saved
```

This is because the Docker network DNS server is populated in containers' `/etc/resolv.conf` in custom networks:

```sh
/ # cat /etc/resolv.conf
# Generated by Docker Engine.
# This file can be edited; Docker Engine will not make further changes once it
# has been modified.

nameserver 127.0.0.11
search vx
options ndots:0

# Based on host file: '/etc/resolv.conf' (internal resolver)
# ExtServers: [host(192.168.17.1)]
# Overrides: []
# Option ndots from: internal
```

## 2.3. running container with aliases

Running a container with network aliases creates DNS records for the aliases

```sh
docker run -d --name nginx \
--network app \
--network-alias webserver \
--network-alias api \
docker.io/library/nginx
```

Client can reach nginx by any of the network names:

```sh
/ # ping nginx -c 1
PING nginx (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.059 ms

--- nginx ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.059/0.059/0.059 ms
/ # ping webserver -c 1
PING webserver (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.049 ms

--- webserver ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.049/0.049/0.049 ms
/ # ping api -c 1
PING api (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.068 ms

--- api ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.068/0.068/0.068 ms
```
